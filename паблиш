import org.eclipse.paho.client.mqttv3.*;
import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;

import javax.net.ssl.SSLSocketFactory;

public class MQTTPublisher {

    private MqttClient client;
    private MqttConnectOptions connOpts;

    public MQTTPublisher(String broker, String clientId, String caFilePath, String clientCertFilePath, String clientKeyFilePath) {
        try {
            client = new MqttClient(broker, clientId, new MemoryPersistence());

            connOpts = new MqttConnectOptions();
            connOpts.setSocketFactory(SSLSocketFactory.getDefault());
            connOpts.setCleanSession(true);

            // Загрузка корневого сертификата
            connOpts.setServerURIs(new String[]{broker});
            connOpts.setSocketFactory(SSLSocketUtil.getSocketFactory(caFilePath, clientCertFilePath, clientKeyFilePath, ""));

            System.out.println("Connecting to broker: " + broker);
            client.connect(connOpts);
            System.out.println("Connected");
        } catch (MqttException e) {
            e.printStackTrace();
        }
    }

    public void publish(String topic, String message) {
        try {
            System.out.println("Publishing message: " + message);
            MqttMessage mqttMessage = new MqttMessage(message.getBytes());
            mqttMessage.setQos(0);
            client.publish(topic, mqttMessage);
            System.out.println("Message published");
        } catch (MqttException e) {
            e.printStackTrace();
        }
    }

    public void disconnect() {
        try {
            client.disconnect();
            System.out.println("Disconnected");
        } catch (MqttException e) {
            e.printStackTrace();
        }
    }
}


В этом примере класс MQTTPublisher имеет конструктор, который устанавливает соединение с брокером MQTT, используя переданные параметры, такие как адрес брокера (broker), идентификатор клиента (clientId), пути к файлам сертификатов (caFilePath, clientCertFilePath и clientKeyFilePath). Затем, у класса есть метод publish, который выполняет публикацию сообщения на указанный топик, и метод disconnect, который отключает соединение с брокером.

Вы можете использовать этот класс следующим образом:

public class Main {
    public static void main(String[] args) {
        // Параметры для подключения и публикации MQTT
        String broker = "ssl://mqtt.example.com:8883";
        String clientId = "publisher";
        String caFilePath = "/path/to/ca.crt";
        String clientCertFilePath = "/path/to/client.crt";
        String clientKeyFilePath = "/path/to/client.key";

        // Создание экземпляра класса MQTTPublisher
        MQTTPublisher publisher = new MQTTPublisher(broker, clientId, caFilePath, clientCertFilePath, clientKeyFilePath);

        // Публикация сообщения на топик
        String topic = "test/topic";
        String message = "Hello, MQTT!";
        publisher.publish(topic, message);

        // Отключение от брокера MQTT
        publisher.disconnect();
    }
}


Вы должны заменить значения broker, clientId, caFilePath, clientCertFilePath и clientKeyFilePath на соответствующие значения для вашего брокера и сертификатов.

Надеюсь, это поможет вам реализовать класс, который выполняет публикацию MQTT с использованием SSL сертификатов. Если у вас возникнут еще вопросы, не стесняйтесь задавать их.
